/* tslint:disable */
/* eslint-disable */
/**
 * ClassHub API
 * ClassHub Backend API 문서
 *
 * The version of the OpenAPI document: v1.0.0
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import * as runtime from '../runtime';
import type {
  LinkShareStatusUpdateRequest,
  OnedayClassCreateRequest,
  OnedayClassResponse,
  SessionResponse,
} from '../models/index';
import {
    LinkShareStatusUpdateRequestFromJSON,
    LinkShareStatusUpdateRequestToJSON,
    OnedayClassCreateRequestFromJSON,
    OnedayClassCreateRequestToJSON,
    OnedayClassResponseFromJSON,
    OnedayClassResponseToJSON,
    SessionResponseFromJSON,
    SessionResponseToJSON,
} from '../models/index';

export interface CreateClassRequest {
    onedayClassCreateRequest: OnedayClassCreateRequest;
}

export interface DeleteClassRequest {
    classId: number;
}

export interface GetClassRequest {
    classId: number;
}

export interface GetClassSessions1Request {
    classId: number;
}

export interface UpdateClassRequest {
    classId: number;
    onedayClassCreateRequest: OnedayClassCreateRequest;
}

export interface UpdateLinkShareStatusRequest {
    classId: number;
    linkShareStatusUpdateRequest: LinkShareStatusUpdateRequest;
}

/**
 * 
 */
export class OnedayClassApi extends runtime.BaseAPI {

    /**
     * Creates request options for createClass without sending the request
     */
    async createClassRequestOpts(requestParameters: CreateClassRequest): Promise<runtime.RequestOpts> {
        if (requestParameters['onedayClassCreateRequest'] == null) {
            throw new runtime.RequiredError(
                'onedayClassCreateRequest',
                'Required parameter "onedayClassCreateRequest" was null or undefined when calling createClass().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.accessToken) {
            const token = this.configuration.accessToken;
            const tokenString = await token("bearerAuth", []);

            if (tokenString) {
                headerParameters["Authorization"] = `Bearer ${tokenString}`;
            }
        }

        let urlPath = `/api/classes`;

        return {
            path: urlPath,
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: OnedayClassCreateRequestToJSON(requestParameters['onedayClassCreateRequest']),
        };
    }

    /**
     * 새로운 원데이클래스를 생성합니다
     * 클래스 생성
     */
    async createClassRaw(requestParameters: CreateClassRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<OnedayClassResponse>> {
        const requestOptions = await this.createClassRequestOpts(requestParameters);
        const response = await this.request(requestOptions, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => OnedayClassResponseFromJSON(jsonValue));
    }

    /**
     * 새로운 원데이클래스를 생성합니다
     * 클래스 생성
     */
    async createClass(requestParameters: CreateClassRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<OnedayClassResponse> {
        const response = await this.createClassRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Creates request options for deleteClass without sending the request
     */
    async deleteClassRequestOpts(requestParameters: DeleteClassRequest): Promise<runtime.RequestOpts> {
        if (requestParameters['classId'] == null) {
            throw new runtime.RequiredError(
                'classId',
                'Required parameter "classId" was null or undefined when calling deleteClass().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.accessToken) {
            const token = this.configuration.accessToken;
            const tokenString = await token("bearerAuth", []);

            if (tokenString) {
                headerParameters["Authorization"] = `Bearer ${tokenString}`;
            }
        }

        let urlPath = `/api/classes/{classId}`;
        urlPath = urlPath.replace(`{${"classId"}}`, encodeURIComponent(String(requestParameters['classId'])));

        return {
            path: urlPath,
            method: 'DELETE',
            headers: headerParameters,
            query: queryParameters,
        };
    }

    /**
     * 클래스를 삭제합니다
     * 클래스 삭제
     */
    async deleteClassRaw(requestParameters: DeleteClassRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<void>> {
        const requestOptions = await this.deleteClassRequestOpts(requestParameters);
        const response = await this.request(requestOptions, initOverrides);

        return new runtime.VoidApiResponse(response);
    }

    /**
     * 클래스를 삭제합니다
     * 클래스 삭제
     */
    async deleteClass(requestParameters: DeleteClassRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<void> {
        await this.deleteClassRaw(requestParameters, initOverrides);
    }

    /**
     * Creates request options for getClass without sending the request
     */
    async getClassRequestOpts(requestParameters: GetClassRequest): Promise<runtime.RequestOpts> {
        if (requestParameters['classId'] == null) {
            throw new runtime.RequiredError(
                'classId',
                'Required parameter "classId" was null or undefined when calling getClass().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.accessToken) {
            const token = this.configuration.accessToken;
            const tokenString = await token("bearerAuth", []);

            if (tokenString) {
                headerParameters["Authorization"] = `Bearer ${tokenString}`;
            }
        }

        let urlPath = `/api/classes/{classId}`;
        urlPath = urlPath.replace(`{${"classId"}}`, encodeURIComponent(String(requestParameters['classId'])));

        return {
            path: urlPath,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        };
    }

    /**
     * 특정 클래스의 상세 정보를 조회합니다
     * 클래스 상세 조회
     */
    async getClassRaw(requestParameters: GetClassRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<OnedayClassResponse>> {
        const requestOptions = await this.getClassRequestOpts(requestParameters);
        const response = await this.request(requestOptions, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => OnedayClassResponseFromJSON(jsonValue));
    }

    /**
     * 특정 클래스의 상세 정보를 조회합니다
     * 클래스 상세 조회
     */
    async getClass(requestParameters: GetClassRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<OnedayClassResponse> {
        const response = await this.getClassRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Creates request options for getClassSessions1 without sending the request
     */
    async getClassSessions1RequestOpts(requestParameters: GetClassSessions1Request): Promise<runtime.RequestOpts> {
        if (requestParameters['classId'] == null) {
            throw new runtime.RequiredError(
                'classId',
                'Required parameter "classId" was null or undefined when calling getClassSessions1().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.accessToken) {
            const token = this.configuration.accessToken;
            const tokenString = await token("bearerAuth", []);

            if (tokenString) {
                headerParameters["Authorization"] = `Bearer ${tokenString}`;
            }
        }

        let urlPath = `/api/classes/{classId}/sessions`;
        urlPath = urlPath.replace(`{${"classId"}}`, encodeURIComponent(String(requestParameters['classId'])));

        return {
            path: urlPath,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        };
    }

    /**
     * 특정 클래스의 모든 세션을 조회합니다
     * 클래스의 세션 목록 조회
     */
    async getClassSessions1Raw(requestParameters: GetClassSessions1Request, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<Array<SessionResponse>>> {
        const requestOptions = await this.getClassSessions1RequestOpts(requestParameters);
        const response = await this.request(requestOptions, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => jsonValue.map(SessionResponseFromJSON));
    }

    /**
     * 특정 클래스의 모든 세션을 조회합니다
     * 클래스의 세션 목록 조회
     */
    async getClassSessions1(requestParameters: GetClassSessions1Request, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<Array<SessionResponse>> {
        const response = await this.getClassSessions1Raw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Creates request options for getMyClasses without sending the request
     */
    async getMyClassesRequestOpts(): Promise<runtime.RequestOpts> {
        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.accessToken) {
            const token = this.configuration.accessToken;
            const tokenString = await token("bearerAuth", []);

            if (tokenString) {
                headerParameters["Authorization"] = `Bearer ${tokenString}`;
            }
        }

        let urlPath = `/api/classes`;

        return {
            path: urlPath,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        };
    }

    /**
     * 로그인한 강사의 모든 클래스를 조회합니다
     * 내 클래스 목록 조회
     */
    async getMyClassesRaw(initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<Array<OnedayClassResponse>>> {
        const requestOptions = await this.getMyClassesRequestOpts();
        const response = await this.request(requestOptions, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => jsonValue.map(OnedayClassResponseFromJSON));
    }

    /**
     * 로그인한 강사의 모든 클래스를 조회합니다
     * 내 클래스 목록 조회
     */
    async getMyClasses(initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<Array<OnedayClassResponse>> {
        const response = await this.getMyClassesRaw(initOverrides);
        return await response.value();
    }

    /**
     * Creates request options for updateClass without sending the request
     */
    async updateClassRequestOpts(requestParameters: UpdateClassRequest): Promise<runtime.RequestOpts> {
        if (requestParameters['classId'] == null) {
            throw new runtime.RequiredError(
                'classId',
                'Required parameter "classId" was null or undefined when calling updateClass().'
            );
        }

        if (requestParameters['onedayClassCreateRequest'] == null) {
            throw new runtime.RequiredError(
                'onedayClassCreateRequest',
                'Required parameter "onedayClassCreateRequest" was null or undefined when calling updateClass().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.accessToken) {
            const token = this.configuration.accessToken;
            const tokenString = await token("bearerAuth", []);

            if (tokenString) {
                headerParameters["Authorization"] = `Bearer ${tokenString}`;
            }
        }

        let urlPath = `/api/classes/{classId}`;
        urlPath = urlPath.replace(`{${"classId"}}`, encodeURIComponent(String(requestParameters['classId'])));

        return {
            path: urlPath,
            method: 'PUT',
            headers: headerParameters,
            query: queryParameters,
            body: OnedayClassCreateRequestToJSON(requestParameters['onedayClassCreateRequest']),
        };
    }

    /**
     * 클래스 정보를 수정합니다
     * 클래스 수정
     */
    async updateClassRaw(requestParameters: UpdateClassRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<OnedayClassResponse>> {
        const requestOptions = await this.updateClassRequestOpts(requestParameters);
        const response = await this.request(requestOptions, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => OnedayClassResponseFromJSON(jsonValue));
    }

    /**
     * 클래스 정보를 수정합니다
     * 클래스 수정
     */
    async updateClass(requestParameters: UpdateClassRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<OnedayClassResponse> {
        const response = await this.updateClassRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Creates request options for updateLinkShareStatus without sending the request
     */
    async updateLinkShareStatusRequestOpts(requestParameters: UpdateLinkShareStatusRequest): Promise<runtime.RequestOpts> {
        if (requestParameters['classId'] == null) {
            throw new runtime.RequiredError(
                'classId',
                'Required parameter "classId" was null or undefined when calling updateLinkShareStatus().'
            );
        }

        if (requestParameters['linkShareStatusUpdateRequest'] == null) {
            throw new runtime.RequiredError(
                'linkShareStatusUpdateRequest',
                'Required parameter "linkShareStatusUpdateRequest" was null or undefined when calling updateLinkShareStatus().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.accessToken) {
            const token = this.configuration.accessToken;
            const tokenString = await token("bearerAuth", []);

            if (tokenString) {
                headerParameters["Authorization"] = `Bearer ${tokenString}`;
            }
        }

        let urlPath = `/api/classes/{classId}/link-share-status`;
        urlPath = urlPath.replace(`{${"classId"}}`, encodeURIComponent(String(requestParameters['classId'])));

        return {
            path: urlPath,
            method: 'PATCH',
            headers: headerParameters,
            query: queryParameters,
            body: LinkShareStatusUpdateRequestToJSON(requestParameters['linkShareStatusUpdateRequest']),
        };
    }

    /**
     * 클래스의 링크 공유 활성화/비활성화 상태를 변경합니다
     * 링크 공유 상태 변경
     */
    async updateLinkShareStatusRaw(requestParameters: UpdateLinkShareStatusRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<OnedayClassResponse>> {
        const requestOptions = await this.updateLinkShareStatusRequestOpts(requestParameters);
        const response = await this.request(requestOptions, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => OnedayClassResponseFromJSON(jsonValue));
    }

    /**
     * 클래스의 링크 공유 활성화/비활성화 상태를 변경합니다
     * 링크 공유 상태 변경
     */
    async updateLinkShareStatus(requestParameters: UpdateLinkShareStatusRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<OnedayClassResponse> {
        const response = await this.updateLinkShareStatusRaw(requestParameters, initOverrides);
        return await response.value();
    }

}
